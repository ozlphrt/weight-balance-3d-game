<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Orientation Debug - Rotation Sliders</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #1A1A2E; 
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            max-width: 300px;
            font-size: 12px;
        }
        .face-control {
            margin: 8px 0;
            padding: 6px;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .face-control h4 {
            margin: 0 0 6px 0;
            color: #ffd700;
            font-size: 11px;
        }
        .slider-group {
            display: flex;
            gap: 6px;
            align-items: center;
            margin: 3px 0;
        }
        .slider-group label {
            min-width: 45px;
            font-size: 10px;
        }
        input[type="range"] {
            width: 80px;
        }
        .value-display {
            min-width: 40px;
            font-family: monospace;
            font-size: 12px;
            color: #00ff00;
        }
        #reset-button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 6px 0;
            font-size: 11px;
        }
        #reset-button:hover {
            background: #ff6666;
        }
        #copy-button {
            background: #44ff44;
            color: black;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
        }
        #copy-button:hover {
            background: #66ff66;
        }
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 250px;
        }
    </style>
</head>
<body>
    <div id="debug-panel">
        <h3>Text Orientation Debug - Rotation Sliders</h3>
        <p>Adjust each face's text orientation and report back the working values.</p>
        
        <div class="face-control">
            <h4>Front Face (Red "1")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="front-flipX" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="front-flipX-value">1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="front-flipY" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="front-flipY-value">1</span>
            </div>
        </div>

        <div class="face-control">
            <h4>Back Face (Blue "2")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="back-flipX" min="-1" max="1" step="1" value="-1">
                <span class="value-display" id="back-flipX-value">-1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="back-flipY" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="back-flipY-value">1</span>
            </div>
        </div>

        <div class="face-control">
            <h4>Right Face (Green "3")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="right-flipX" min="-1" max="1" step="1" value="-1">
                <span class="value-display" id="right-flipX-value">-1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="right-flipY" min="-1" max="1" step="1" value="-1">
                <span class="value-display" id="right-flipY-value">-1</span>
            </div>
        </div>

        <div class="face-control">
            <h4>Left Face (Yellow "4")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="left-flipX" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="left-flipX-value">1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="left-flipY" min="-1" max="1" step="1" value="-1">
                <span class="value-display" id="left-flipY-value">-1</span>
            </div>
        </div>

        <div class="face-control">
            <h4>Top Face (Purple "5")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="top-flipX" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="top-flipX-value">1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="top-flipY" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="top-flipY-value">1</span>
            </div>
        </div>

        <div class="face-control">
            <h4>Bottom Face (Orange "6")</h4>
            <div class="slider-group">
                <label>Flip X:</label>
                <input type="range" id="bottom-flipX" min="-1" max="1" step="1" value="-1">
                <span class="value-display" id="bottom-flipX-value">-1</span>
            </div>
            <div class="slider-group">
                <label>Flip Y:</label>
                <input type="range" id="bottom-flipY" min="-1" max="1" step="1" value="1">
                <span class="value-display" id="bottom-flipY-value">1</span>
            </div>
        </div>

        <button id="reset-button" onclick="window.resetToDefaults()">Reset to Defaults</button>
        <button id="copy-button" onclick="window.copyValues()">Show Values</button>
        <button onclick="alert('Button click works!')">Test Button</button>
        <div id="values-display" style="display: none; margin-top: 15px; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 5px; font-family: monospace; font-size: 12px; white-space: pre-line;"></div>
    </div>

    <div id="info">
        <p><strong>Instructions:</strong></p>
        <p>1. Rotate camera to see all faces</p>
        <p>2. Adjust sliders until text looks correct</p>
        <p>3. Report back the working values</p>
        <p><strong>Controls:</strong> Mouse: Rotate | Wheel: Zoom</p>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.180.0/build/three.module.js';

        // Global variables
        let scene, camera, renderer, cube;
        let faceSettings = {
            front: { flipX: 1, flipY: 1 },
            back: { flipX: -1, flipY: 1 },
            right: { flipX: -1, flipY: -1 },
            left: { flipX: 1, flipY: -1 },
            top: { flipX: 1, flipY: 1 },
            bottom: { flipX: -1, flipY: 1 }
        };

        function main() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1A1A2E);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create test cube
            createTestCube();
            
            // Setup camera controls
            setupCameraControls();
            
            // Setup slider controls
            setupSliderControls();

            // Start animation
            animate();
        }

        function createTestCube() {
            const size = 1;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({
                color: 0x666666,
                shininess: 30,
                specular: 0x222222,
                transparent: true,
                opacity: 0.3
            });
            
            cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, size/2, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // Add test numbers to all faces
            addTestWeightDisplay(cube, size);
            
            scene.add(cube);
        }

        function addTestWeightDisplay(mesh, size) {
            const textGeometry = new THREE.PlaneGeometry(size * 0.95, size * 0.95);
            
            const faces = [
                { pos: [0, 0, size/2 + 0.01], rot: [0, 0, 0], name: 'front', test: '1', color: 'red' },
                { pos: [0, 0, -size/2 - 0.01], rot: [0, Math.PI, 0], name: 'back', test: '2', color: 'blue' },
                { pos: [size/2 + 0.01, 0, 0], rot: [0, -Math.PI/2, 0], name: 'right', test: '3', color: 'green' },
                { pos: [-size/2 - 0.01, 0, 0], rot: [0, Math.PI/2, 0], name: 'left', test: '4', color: 'yellow' },
                { pos: [0, size/2 + 0.01, 0], rot: [-Math.PI/2, 0, 0], name: 'top', test: '5', color: 'purple' },
                { pos: [0, -size/2 - 0.01, 0], rot: [Math.PI/2, 0, 0], name: 'bottom', test: '6', color: 'orange' }
            ];
            
            faces.forEach((face) => {
                const faceCanvas = document.createElement('canvas');
                const faceContext = faceCanvas.getContext('2d');
                faceCanvas.width = 256;
                faceCanvas.height = 256;
                
                faceContext.fillStyle = face.color;
                faceContext.font = 'bold 120px Arial';
                faceContext.textAlign = 'center';
                faceContext.textBaseline = 'middle';
                
                // Apply current settings for this face
                const settings = faceSettings[face.name];
                const scaleX = settings.flipX;
                const scaleY = settings.flipY;
                
                faceContext.scale(scaleX, scaleY);
                const textX = scaleX === -1 ? -128 : 128;
                const textY = scaleY === -1 ? -128 : 128;
                faceContext.fillText(face.test, textX, textY);
                
                const faceTexture = new THREE.CanvasTexture(faceCanvas);
                const textMaterial = new THREE.MeshBasicMaterial({
                    map: faceTexture,
                    transparent: true,
                    alphaTest: 0.1,
                    side: THREE.DoubleSide
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(face.pos[0], face.pos[1], face.pos[2]);
                textMesh.rotation.set(face.rot[0], face.rot[1], face.rot[2]);
                textMesh.userData = { faceName: face.name }; // Store face name for updates
                mesh.add(textMesh);
            });
        }

        function updateFaceText(faceName) {
            // Find the text mesh for this face
            const textMesh = cube.children.find(child => 
                child.userData && child.userData.faceName === faceName
            );
            
            if (!textMesh) return;
            
            // Get current settings
            const settings = faceSettings[faceName];
            
            // Create new canvas with updated settings
            const faceCanvas = document.createElement('canvas');
            const faceContext = faceCanvas.getContext('2d');
            faceCanvas.width = 256;
            faceCanvas.height = 256;
            
            // Set color based on face
            const colors = {
                front: 'red', back: 'blue', right: 'green',
                left: 'yellow', top: 'purple', bottom: 'orange'
            };
            const numbers = {
                front: '1', back: '2', right: '3',
                left: '4', top: '5', bottom: '6'
            };
            
            faceContext.fillStyle = colors[faceName];
            faceContext.font = 'bold 120px Arial';
            faceContext.textAlign = 'center';
            faceContext.textBaseline = 'middle';
            
            // Apply current settings
            const scaleX = settings.flipX;
            const scaleY = settings.flipY;
            
            faceContext.scale(scaleX, scaleY);
            const textX = scaleX === -1 ? -128 : 128;
            const textY = scaleY === -1 ? -128 : 128;
            faceContext.fillText(numbers[faceName], textX, textY);
            
            // Update texture
            const newTexture = new THREE.CanvasTexture(faceCanvas);
            textMesh.material.map = newTexture;
            textMesh.material.needsUpdate = true;
        }

        function setupSliderControls() {
            const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
            
            faces.forEach(faceName => {
                const flipXSlider = document.getElementById(`${faceName}-flipX`);
                const flipYSlider = document.getElementById(`${faceName}-flipY`);
                const flipXValue = document.getElementById(`${faceName}-flipX-value`);
                const flipYValue = document.getElementById(`${faceName}-flipY-value`);
                
                flipXSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    faceSettings[faceName].flipX = value;
                    flipXValue.textContent = value;
                    updateFaceText(faceName);
                });
                
                flipYSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    faceSettings[faceName].flipY = value;
                    flipYValue.textContent = value;
                    updateFaceText(faceName);
                });
            });
        }

        window.resetToDefaults = function() {
            faceSettings = {
                front: { flipX: 1, flipY: 1 },
                back: { flipX: -1, flipY: 1 },
                right: { flipX: -1, flipY: -1 },
                left: { flipX: 1, flipY: -1 },
                top: { flipX: 1, flipY: 1 },
                bottom: { flipX: -1, flipY: 1 }
            };
            
            // Update sliders
            const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
            faces.forEach(faceName => {
                const flipXSlider = document.getElementById(`${faceName}-flipX`);
                const flipYSlider = document.getElementById(`${faceName}-flipY`);
                const flipXValue = document.getElementById(`${faceName}-flipX-value`);
                const flipYValue = document.getElementById(`${faceName}-flipY-value`);
                
                flipXSlider.value = faceSettings[faceName].flipX;
                flipYSlider.value = faceSettings[faceName].flipY;
                flipXValue.textContent = faceSettings[faceName].flipX;
                flipYValue.textContent = faceSettings[faceName].flipY;
                
                updateFaceText(faceName);
            });
        }

        window.copyValues = function() {
            console.log('copyValues function called');
            console.log('faceSettings:', faceSettings);
            
            const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
            const faceNames = {
                front: 'Front', back: 'Back', right: 'Right', 
                left: 'Left', top: 'Top', bottom: 'Bottom'
            };
            
            let output = '';
            faces.forEach(faceName => {
                const settings = faceSettings[faceName];
                output += `${faceNames[faceName]}: flipX=${settings.flipX}, flipY=${settings.flipY}\n`;
            });
            
            console.log('Output:', output);
            
            // Display values on screen
            const valuesDisplay = document.getElementById('values-display');
            console.log('valuesDisplay element:', valuesDisplay);
            
            if (valuesDisplay) {
                valuesDisplay.textContent = output;
                valuesDisplay.style.display = 'block';
                console.log('Values displayed on screen');
            } else {
                console.error('values-display element not found');
            }
            
            // Also try to copy to clipboard
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(output);
                }
            } catch (err) {
                console.log('Clipboard copy failed:', err);
            }
            
            // Update button text
            const button = document.getElementById('copy-button');
            if (button) {
                button.textContent = 'Values Shown!';
                button.style.background = '#00ff00';
                
                setTimeout(() => {
                    button.textContent = 'Show Values';
                    button.style.background = '#44ff44';
                }, 2000);
            }
        }

        function setupCameraControls() {
            let isLeftMouseDown = false;
            let isRightMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let currentX = 0, currentY = 0;
            let targetPanX = 0, targetPanY = 0;
            let currentPanX = 0, currentPanY = 0;
            
            let radius = 8;
            const minRadius = 3;
            const maxRadius = 20;
            const target = new THREE.Vector3(0, 0, 0);
            
            currentX = Math.PI / 4;
            currentY = Math.PI / 4;
            targetX = currentX;
            targetY = currentY;
            
            function updateCameraPosition() {
                const x = Math.cos(currentY) * Math.cos(currentX) * radius;
                const y = Math.sin(currentY) * radius;
                const z = Math.cos(currentY) * Math.sin(currentX) * radius;
                
                camera.position.set(x + currentPanX, y + currentPanY, z);
                camera.lookAt(target.x + currentPanX, target.y + currentPanY, target.z);
            }
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                if (event.button === 0) {
                    isLeftMouseDown = true;
                    renderer.domElement.style.cursor = 'grabbing';
                } else if (event.button === 2) {
                    isRightMouseDown = true;
                    renderer.domElement.style.cursor = 'move';
                }
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isLeftMouseDown = false;
                isRightMouseDown = false;
                renderer.domElement.style.cursor = 'grab';
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                if (isLeftMouseDown) {
                    targetX += deltaX * 0.01;
                    targetY += deltaY * 0.01;
                    targetY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, targetY));
                } else if (isRightMouseDown) {
                    const panSpeed = 0.01;
                    targetPanX -= deltaX * panSpeed;
                    targetPanY += deltaY * panSpeed;
                }
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                const delta = event.deltaY * 0.002;
                radius += delta;
                radius = Math.max(minRadius, Math.min(maxRadius, radius));
                updateCameraPosition();
            });
            
            renderer.domElement.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
            
            function cameraAnimate() {
                currentX += (targetX - currentX) * 0.1;
                currentY += (targetY - currentY) * 0.1;
                currentPanX += (targetPanX - currentPanX) * 0.1;
                currentPanY += (targetPanY - currentPanY) * 0.1;
                
                updateCameraPosition();
                requestAnimationFrame(cameraAnimate);
            }
            
            cameraAnimate();
            updateCameraPosition();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        main();
    </script>
</body>
</html>
