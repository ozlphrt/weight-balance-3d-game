# Cursor AI Project Rules - Weight Balance

## Project Overview
This is a 3D physics-based puzzle game built with Three.js and Cannon-es. The project follows a modular architecture with clear separation of concerns.

## Code Style Preferences

### JavaScript/TypeScript
- **ES6+ features**: Use modern JavaScript syntax
- **TypeScript**: Optional for prototype, preferred for production
- **Indentation**: 2 spaces (no tabs)
- **Quotes**: Single quotes for strings
- **Semicolons**: Always use semicolons
- **Line length**: 80 characters maximum

### Naming Conventions
- **Variables**: camelCase (`cubeWeight`, `isPlaced`)
- **Functions**: camelCase (`createCube`, `handlePlacement`)
- **Constants**: UPPER_SNAKE_CASE (`MAX_CUBES`, `PHYSICS_TIMESTEP`)
- **Classes**: PascalCase (`CubeManager`, `PhysicsWorld`)
- **Files**: kebab-case (`cube-manager.js`, `physics-world.js`)

### Code Organization
- **Single responsibility**: Each function should do one thing
- **Modular design**: Clear separation between scene, physics, camera, etc.
- **Error handling**: Always handle potential errors gracefully
- **Comments**: Document complex logic and physics calculations
- **Console logging**: Use for debugging, remove before production

## File Organization Rules

### Source Code Structure
```
src/
├── main.js           # Application entry point
├── scene.js          # Three.js scene management
├── physics.js        # Cannon-es physics world
├── camera.js         # Camera controls
├── cubes.js          # Cube creation & management
├── placement.js      # Surface placement logic
└── utils.js          # Helper functions
```

### Import/Export Standards
- **ES6 modules**: Use import/export syntax
- **Named exports**: Prefer named exports over default exports
- **Import order**: External libraries first, then internal modules
- **Barrel exports**: Use index.js files for clean imports when needed

### Example Import Structure
```javascript
// External libraries
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

// Internal modules
import { createScene } from './scene.js';
import { createPhysicsWorld } from './physics.js';
import { setupCamera } from './camera.js';
```

## Three.js Specific Rules

### Scene Management
- **Always dispose**: Properly dispose of geometries, materials, and textures
- **Object pooling**: Reuse objects when possible for performance
- **Memory management**: Monitor memory usage and clean up unused objects
- **Coordinate system**: Always state coordinate system assumptions explicitly

### Camera Controls
- **Default to OrbitControls**: Use Three.js OrbitControls for camera movement
- **State camera setup**: Position, target, up vector, and control mappings
- **Control transition**: Show how to cleanly dispose and initialize controls
- **Coordinate system**: Clarify which coordinate system is being used

### Physics Integration
- **Synchronization**: Keep Three.js meshes and Cannon-es bodies in sync
- **Timestep**: Use fixed timestep (1/60s) for consistent physics
- **Body creation**: Create physics bodies when objects are placed
- **Body cleanup**: Remove physics bodies when objects are destroyed

## Physics-Specific Rules

### Cannon-es Usage
- **Modern fork**: Use Cannon-es, not deprecated Cannon.js
- **Fixed timestep**: Always use fixed timestep for physics
- **Body properties**: Set appropriate mass, friction, and restitution
- **Collision shapes**: Use appropriate shapes for different objects
- **World cleanup**: Properly dispose of physics world and bodies

### Physics Debugging
- **Visual debugging**: Use helpers (AxesHelper, CameraHelper) before math
- **Coordinate system**: State coordinate system and expected value ranges
- **Vector operations**: Show coordinate system and matrix transformations
- **Performance**: Monitor physics performance and optimize when needed

## UI/Interaction Preferences

### Controls
- **No slider controls**: Default to hover + drag interactions
- **Mouse drag**: Implement mouse drag with delta calculations
- **Drag interaction math**: Explain how mouse movement maps to parameter changes
- **Default to glassmorphism**: Semi-transparent backgrounds, backdrop blur, subtle borders

### User Experience
- **Responsive design**: Ensure controls work on different screen sizes
- **Visual feedback**: Provide clear feedback for user actions
- **Error handling**: Graceful handling of invalid user input
- **Performance**: Maintain 60fps during user interactions

## Development Workflow

### When to Ask vs. Implement
- **Ask for clarification**: When requirements are ambiguous
- **Implement directly**: When requirements are clear and well-defined
- **Challenge assumptions**: When approach seems flawed or inefficient
- **Present alternatives**: When better solutions exist

### Code Quality Standards
- **Test as you go**: Physics must feel good and behave realistically
- **Keep it minimal**: Prototype scope only, no feature creep
- **Reference documentation**: Follow the architecture and task documents
- **Be explicit**: State assumptions and coordinate systems clearly

### Error Handling
- **Graceful failures**: Handle user input errors without crashing
- **Console logging**: Use for debugging, remove before production
- **Validation**: Validate inputs before processing
- **Recovery**: Provide ways to recover from errors

## Performance Guidelines

### Rendering
- **60fps target**: Maintain smooth performance
- **Frustum culling**: Only render visible objects
- **Object pooling**: Reuse objects when possible
- **Memory management**: Monitor and clean up unused objects

### Physics
- **Fixed timestep**: Use consistent physics timestep
- **Body optimization**: Use appropriate collision shapes
- **Sleeping bodies**: Deactivate static objects when possible
- **Performance monitoring**: Track physics performance

## Documentation Standards

### Code Comments
- **Complex logic**: Document physics calculations and coordinate transformations
- **Function purpose**: Explain what each function does
- **Parameters**: Document function parameters and return values
- **Coordinate systems**: Always state which coordinate system is being used

### API Documentation
- **Function signatures**: Clear parameter and return types
- **Usage examples**: Provide examples for complex functions
- **Coordinate system**: Document coordinate system assumptions
- **Performance notes**: Document performance considerations

## Testing Requirements

### Manual Testing
- **Physics behavior**: Test realistic physics behavior
- **User interactions**: Test all user input scenarios
- **Performance**: Verify 60fps performance
- **Browser compatibility**: Test in Chrome, Firefox, Safari

### Debugging Tools
- **Visual helpers**: Use AxesHelper, CameraHelper, wireframes
- **Console logging**: Detailed logging for development
- **Performance monitoring**: FPS counter and memory usage
- **Physics visualization**: Show physics bodies and constraints

## Security Considerations

### Client-Side Security
- **Input validation**: Validate all user inputs
- **XSS prevention**: Sanitize any user-generated content
- **Dependency security**: Keep dependencies updated
- **No sensitive data**: Don't store sensitive information client-side

## Future Considerations

### Scalability
- **Modular architecture**: Design for easy extension
- **Performance optimization**: Plan for larger scenes and more objects
- **Mobile support**: Consider touch controls and responsive design
- **Cross-platform**: Design for multiple platforms

### Maintenance
- **Code organization**: Keep code organized and maintainable
- **Documentation**: Keep documentation up to date
- **Dependencies**: Regularly update and audit dependencies
- **Performance**: Monitor and optimize performance over time
