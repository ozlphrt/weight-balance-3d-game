<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Orientation Debug - Simple</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #1A1A2E; 
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Text Orientation Debug Test</h3>
        <p><strong>Test Results:</strong></p>
        <p>Front (red "1"): No flip</p>
        <p>Back (blue "2"): Horizontal flip</p>
        <p>Right (green "3"): Vertical flip</p>
        <p>Left (yellow "4"): Both flips</p>
        <p>Top (purple "5"): No flip</p>
        <p>Bottom (orange "6"): Horizontal flip</p>
        <p><strong>Instructions:</strong> Rotate camera to see all faces. Tell me which numbers look correctly oriented!</p>
    </div>
    
    <div id="controls">
        <p><strong>Controls:</strong></p>
        <p>Mouse: Rotate camera</p>
        <p>Wheel: Zoom in/out</p>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.180.0/build/three.module.js';

        function main() {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1A1A2E);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create a single test cube
            const size = 1;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({
                color: 0x666666,
                shininess: 30,
                specular: 0x222222,
                transparent: true,
                opacity: 0.3
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, size/2, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // Add test numbers to all faces with different transformations
            addTestWeightDisplay(cube, size);
            
            scene.add(cube);

            // Function to add test numbers with different transformations
            function addTestWeightDisplay(mesh, size) {
                const textGeometry = new THREE.PlaneGeometry(size * 0.95, size * 0.95);
                
                const faces = [
                    { pos: [0, 0, size/2 + 0.01], rot: [0, 0, 0], name: 'front', test: '1', color: 'red' },
                    { pos: [0, 0, -size/2 - 0.01], rot: [0, Math.PI, 0], name: 'back', test: '2', color: 'blue' },
                    { pos: [size/2 + 0.01, 0, 0], rot: [0, -Math.PI/2, 0], name: 'right', test: '3', color: 'green' },
                    { pos: [-size/2 - 0.01, 0, 0], rot: [0, Math.PI/2, 0], name: 'left', test: '4', color: 'yellow' },
                    { pos: [0, size/2 + 0.01, 0], rot: [-Math.PI/2, 0, 0], name: 'top', test: '5', color: 'purple' },
                    { pos: [0, -size/2 - 0.01, 0], rot: [Math.PI/2, 0, 0], name: 'bottom', test: '6', color: 'orange' }
                ];
                
                faces.forEach((face, index) => {
                    const faceCanvas = document.createElement('canvas');
                    const faceContext = faceCanvas.getContext('2d');
                    faceCanvas.width = 256;
                    faceCanvas.height = 256;
                    
                    faceContext.fillStyle = face.color;
                    faceContext.font = 'bold 120px Arial';
                    faceContext.textAlign = 'center';
                    faceContext.textBaseline = 'middle';
                    
                    // Test different transformations
                    if (index === 0) {
                        // Front: No flip
                        faceContext.fillText(face.test, 128, 128);
                    } else if (index === 1) {
                        // Back: Horizontal flip
                        faceContext.scale(-1, 1);
                        faceContext.fillText(face.test, -128, 128);
                    } else if (index === 2) {
                        // Right: Vertical flip
                        faceContext.scale(1, -1);
                        faceContext.fillText(face.test, 128, -128);
                    } else if (index === 3) {
                        // Left: Both flips
                        faceContext.scale(-1, -1);
                        faceContext.fillText(face.test, -128, -128);
                    } else if (index === 4) {
                        // Top: No flip
                        faceContext.fillText(face.test, 128, 128);
                    } else {
                        // Bottom: Horizontal flip
                        faceContext.scale(-1, 1);
                        faceContext.fillText(face.test, -128, 128);
                    }
                    
                    const faceTexture = new THREE.CanvasTexture(faceCanvas);
                    const textMaterial = new THREE.MeshBasicMaterial({
                        map: faceTexture,
                        transparent: true,
                        alphaTest: 0.1,
                        side: THREE.DoubleSide
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(face.pos[0], face.pos[1], face.pos[2]);
                    textMesh.rotation.set(face.rot[0], face.rot[1], face.rot[2]);
                    mesh.add(textMesh);
                });
            }

            // Camera controls - exact copy from main game
            let isLeftMouseDown = false;
            let isRightMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let currentX = 0, currentY = 0;
            let targetPanX = 0, targetPanY = 0;
            let currentPanX = 0, currentPanY = 0;
            
            // Camera orbit parameters
            let radius = 8;
            const minRadius = 3;
            const maxRadius = 20;
            const target = new THREE.Vector3(0, 0, 0); // Target cube center
            
            // Set initial orbit angles
            currentX = Math.PI / 4; // 45 degrees around
            currentY = Math.PI / 4; // 45 degrees up
            targetX = currentX;
            targetY = currentY;
            
            // Update camera position based on orbit
            function updateCameraPosition() {
                const x = Math.cos(currentY) * Math.cos(currentX) * radius;
                const y = Math.sin(currentY) * radius;
                const z = Math.cos(currentY) * Math.sin(currentX) * radius;
                
                camera.position.set(x + currentPanX, y + currentPanY, z);
                camera.lookAt(target.x + currentPanX, target.y + currentPanY, target.z);
            }
            
            // Mouse event handlers
            function onMouseDown(event) {
                if (event.button === 0) { // Left click - orbit
                    isLeftMouseDown = true;
                    renderer.domElement.style.cursor = 'grabbing';
                } else if (event.button === 2) { // Right click - pan
                    isRightMouseDown = true;
                    renderer.domElement.style.cursor = 'move';
                }
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onMouseUp(event) {
                if (event.button === 0) {
                    isLeftMouseDown = false;
                } else if (event.button === 2) {
                    isRightMouseDown = false;
                }
                
                if (!isLeftMouseDown && !isRightMouseDown) {
                    renderer.domElement.style.cursor = 'grab';
                }
            }
            
            function onMouseMove(event) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                if (isLeftMouseDown) {
                    // Left click - orbit around target
                    targetX += deltaX * 0.01;
                    targetY += deltaY * 0.01;
                    
                    // Clamp vertical rotation
                    targetY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, targetY));
                } else if (isRightMouseDown) {
                    // Right click - pan camera
                    const panSpeed = 0.01;
                    targetPanX -= deltaX * panSpeed;
                    targetPanY += deltaY * panSpeed;
                }
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onWheel(event) {
                event.preventDefault();
                
                // More responsive zoom
                const delta = event.deltaY * 0.002;
                radius += delta;
                
                // Clamp radius
                radius = Math.max(minRadius, Math.min(maxRadius, radius));
                
                updateCameraPosition();
            }
            
            // Prevent context menu on right click
            function onContextMenu(event) {
                event.preventDefault();
            }
            
            // Smooth camera movement
            function cameraAnimate() {
                currentX += (targetX - currentX) * 0.1;
                currentY += (targetY - currentY) * 0.1;
                currentPanX += (targetPanX - currentPanX) * 0.1;
                currentPanY += (targetPanY - currentPanY) * 0.1;
                
                updateCameraPosition();
                requestAnimationFrame(cameraAnimate);
            }
            
            // Add event listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('contextmenu', onContextMenu);
            
            // Start camera animation
            cameraAnimate();
            
            // Initial camera position
            updateCameraPosition();

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        main();
    </script>
</body>
</html>
